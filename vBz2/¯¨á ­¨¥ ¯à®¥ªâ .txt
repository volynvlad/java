Если есть тесты, то Main не нужен
Требования
 
1. При  реализации  иерархии  наследования  производный  класс  должен  расширять 
суперкласс  новыми  свойствами,  для  чего  следует  разобраться  в  предметной  области задачи. 
2. Классы-сущности не следует перенасыщать методами, выполняющими функциональные 
действия (методами бизнес-логики, такими как поиск и т.д.). 
  Для сортировок наборов объектов использовать реализацию интерфейса Comparator. 
4.  При решении задачи использовать паттерны Creator, Factory Method. 
5. Все классы приложения должны быть структурированы по пакетам. 
6. Оформление кода должно соответствовать Java Code Convention. 
7.  Параметры, необходимые для создания объектов, должны вводиться с помощью чтения 
данных из файла (.txt). Должна присутствовать обработка (замена значений по умолчанию 
или игнорирование) некорректных данных инициализации объекта. 
8.  Для записи логов использовать Log4J или Log4J2. Допускается SLF4J. 
9.  Код должен быть покрыт Unit-тестами. Использовать JUnit4, Mockito или EasyMock. 
10. Пользовательское меню для приложения не реализовывать. 
 
Определить иерархию конфет и прочих сладостей. Создать несколько объектов-конфет. Собрать детский подарок с определением его веса.
Провести сортировку конфет в подарке на основе одного из параметров.
Найти конфету в подарке, соответствующую заданному диапазону содержания сахара. 

1.
  Для записи логов использовать Log4J или Log4J2. Допускается SLF4J. 
  Код должен быть покрыт Unit-тестами. Использовать JUnit4, Mockito или EasyMock. 
Подключаем логи, тесты. Создаем папку lib на одном уровне с src и копируем туда hamcrest-core-1.3.jar и junit-4.12.jar для тестов
и log4j-api-2.7.jar и log4j-core-2.7.jar для логов. Подключаем библиотеки в Project Steeucture. Добавляем папку log 
на одном уровне с src, туда будем писать логи. Добавляем файл конфигурации для логов log4j2.xml в src

<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
        <File name="File" fileName="log/logs.log">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </File>
    </Appenders>
    <Loggers>
        <Root level="info">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="File"/>
        </Root>
    </Loggers>
</Configuration>

2.
  Все классы приложения должны быть структурированы по пакетам. 
Создаем пакет для сущностей:entity.
3. Определим иерархию сущностей.
  При  реализации  иерархии  наследования  производный  класс  должен  расширять 
суперкласс  новыми  свойствами,  для  чего  следует  разобраться  в  предметной  области задачи. 
  Классы-сущности не следует перенасыщать методами, выполняющими функциональные 
действия (методами бизнес-логики, такими как поиск и т.д.). 
Базовый абстрактный класс Sweet (сладость).
У любо	 сладости есть id (sweetId) в базе (не отдельной сладости, а сорта сладости, название (name), производитель (producer),
вес(weight)  и содержание сахара(amountOfSugar).
Id будет возникать из базы данных, поэтому тип long.
name типа String.
Круг стран-производителей постоянен и ограничен, поэтому можно создать перечисление 
public enum Producer {
    RUSSIA,
    USA,
    CHINA,
    POLAND,
    BELARUS
}
и разместить его в отдельном файле.
От сладости (Sweet) могут наследоваться различные виды сладостей, например, вафли, мармелад, зефир, конфеты.
Введем один из конкретных видов сладостей: вафли (Wafer) дочерний от сладость (Sweet).
сладости (Sweet) добавим еще одно поле ароматизатор (aroma).
Поскольку ароматизаторы конечны и постоянны выделим их в отдельное перечисление и отдельный файл
public enum Aroma {
    DUSCHES,
    COLA,
    PEPSI,
    CHOCOLATE
}
Кроме вафель (Wafer) создадим абстрактный класс конфета (Candy), также отнаследуем его от сладости (Sweet).
В дополнение к сладости добавим одно поле вкус (taste).
Так как вкусов также ограниченное постоянное количество (сладкий, кислый, горький, соленый)выделим их в еще одно перечисление
//Вкус:сладкий, кислый, горький, соленый
public enum Taste {
    SUGARY,
    SOUR,
    BITTER,
    SALT
}
и соответственно в отдельный файл.

От конфеты (Candy) отнаследует класс леденец (Lollipop).
В дополнение к конфете леденец будет иметь форму 
//Форма леденцов: диск, шар, тросточка, петушок, тюльпан
public enum Form {
    DISK,
    SPHERE,
    CANE,
    COCKEREL,
    TULIP
}
Форму также выделим в отдельное перечисление и отдельный файл.
От абстрактного класса конфета (Candy) отнаследуем класс Глазированная конфета (GlazedCandy)это коннфета+глазурь.
Виды глазури известны заранее и конечны, поэтому выделяем их в отдельное перечисление и соответственно в отдельный файл.
//Глазурь: молочная, шоколадная, лимонная, белый шоколад
public enum Frosting {
    MILK,
    CHOCOLATE,
    CITRIC,
    WHITE_CHOCOLATE
}

Создадим класс подарок (Gift). Он будет содержать список сладостей (Sweet). Т.е. указателей на абстрактные объекты самого общего типа.
В качестве списка будем использовать LinkedList имеющий больше операций, чем ArrayList, а значит более сложный и требующий больше памяти.
Класс представляет структуру данных связного списка и реализует интерфейсы List, Dequeue, Queue.
Операции вставки и удаления в середине списка работают у него эффективнее. Но хуже обстоит дело с операциями произвольного доступа.
Для добавления элемента в конец списка используется метод add(), для удаления используется метод remove().
И будет содержать поле вес (weight), как сумму всех сладостей.

Далее, нам надо считать данные из файла. Пакет read. Класс SweetReader. 
Его задача считать данные из текстового файла в список строк LinkedList<String> 

Создадим хранилище для конфет. Пакет store, класс SweetStorage. Класс хранит конфеты в списке LinkedList<Sweet>.
Есть метод для добавления конфеты и извлечения конфеты. Хранилище может быть только одно, поэтому исползуем паттерн Singleton.
Создадим свою ошибку StorageException. Для обозначения ошибок с хранилищем.

Предполагается, что данные о сладостях в текстовом файле будут храниться в виде строк (по одной на каждую сладость).
Например, "type=Glazed_Candy id=1 name=alenka weight=25 sugar=15 producer=russia taste=sugary frosting=milk"
Поскольку сладости могут быть различных типов, то в строке могут быть разное колличество данных.
Но в общем виде: "имя данного=значение" пробел "имя данного=значение" пробел и т.д.
Создадим пакет util в нем в качестве класса SweetTags со статическими константными полями будем хранить все имена данных,
которые могут встречаться в исходном файле данных.
public class SweetTags {
    public static final String ID = "ID=";
    public static final String NAME = "NAME=";
    public static final String AROMA = "AROMA=";
    public static final String FROSTING = "FROSTING=";
    public static final String TYPE = "TYPE=";
    public static final String PRODUCER = "PRODUCER=";
    public static final String TASTE = "TASTE=";
    public static final String FORM = "FORM=";
    public static final String WEIGHT = "WEIGHT=";
    public static final String SUGAR = "SUGAR=";
}
В этот же пакет поместим перечисление с типами сладостей:
public enum TypeSweet {
    GLAZED_CANDY,
    LOLLIPOP,
    WAFER
}

Создадим пакет valid и класс SweetValidator в нем, который будет проверять, является ли строка корретной информацией о сладости

Создадим пакет parse и класс SweetParser в нем, который будет разбирать строку и вытаскивать из нее нужную информацию.

Создадим пакет create и класс SweetCreator нем. В конструктор приходит парсер, уже инициализированный конкретной строкой.
На основе этой строки создаем объект определенного типа. Шаблон creator.





Создадим пакет init и класс init в нем. В метод приходит список из строк. Для каждой строки создается парсер и креатор на основе парсера.

В зависимости от типа (определяет парсер) создается объект сладости нужного типа и добавляется в хранилище.

Создадим пакет compare для компараторов.
Собственно задача в action.
Collections.sort(sweets, new SweetNameComparator().thenComparing(new SweetWeightComparator())); сортировка по имени и по весу в пределах имени

entity+
read+
store+
util+
valid+
parse+
action+
create+
init+
compare+
